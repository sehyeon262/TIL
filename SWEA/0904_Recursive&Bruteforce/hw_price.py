# 상태를 (문자열, 남은교환수)로 두고 재귀.
# 남은교환수가 0이면 현재 값 반환.
# 아니면 모든 (i<j) 교환을 시도해 다음 상태로 이동하며 최댓값을 반환.
# (문자열, 남은교환수)를 키로 메모해서 같은 상태 재방문을 차단.

# T = int(input())
#
# for test_case in range(1, T + 1):
#     nums, N = input().split()
#     N = int(N)
#
#     arr = []    # 숫자판 리스트
#     for x in nums:
#         arr.append(x)

# ---------------------------------------------------------------
# add((k, 숫자))
# set()

T = int(input())
# 교환 횟수 k를 단계로 표현
def solve(k):
    # 가지치기
    if k번 교환해서 만든 숫자열을 이전에 만든적이 있다면
        return

    # 종료
    if k == cnt:
        # 만든 숫자가 최대값인가? 비교해서 갱신

    # 재귀호출(다음단계)
    # 자리를 교환해서 다음 단계(다음 교환횟수)
    # 앞쪽자리 인덱스 i : 0 ~ N - 2
    # 뒤쪽자리 인덱스 j: i + 1 ~ N-1

    # i와 j를 정해서 자리바꾸기
    # 자리바꾼 다음에 다음 교환 횟수로 => 재귀호출, 교환 횟수 +1
    # i와 j를 바꿔서 원상복귀

for test_case in range(1, T+1):
    nums, cnt = input().split()

    # 교환 횟수
    cnt = int(input())

    N = len(nums)

    max_price = 0

    # 세트 안에는 (교환 횟수 k, k번 교환해서 만든 숫자열) 튜플로 저장
    # 3번의 교환을 통해서 "12345" 라는 숫자열을 이전에 만든 적이 있다면
    # 나중에 교환순서는 다르지만 3번 교환을 통해 "12345"를 만들면
    # 여기서 다시 만드는 모든 숫자열은 중복이 된다.
    check = set()

    # 교환 안했으니 교환횟수 0부터 시작
    solve(0)

    print(f'#{test_case} {max_price}')