# 교재_연습문제3_p.88
# 두 가지 방법 => 1. 인접행렬, 2. 인접리스트

'''
7 8
1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
'''
# V: 정점의 개수
# E: 간선의 개수
V, E = map(int, input().split())

# 정점들의 연결 정보가 입력으로 들어온다
graph = list(map(int, input().split()))

# 인접리스트
# 어떤 정점 X와 연결되어있는 정점들을 리스트로 가지고 있다
# adjL[x[] = [1, 2, 3] => x번 정점과 연결되어있는 정점들은 1번, 2번, 3번이 있다.

adj = [[] for _ in range(V+1)]


# 간선의 개수만큼 자름
# i: 간선 번호
for i in range(E):
    # s 정점과 e 정점은 연결되어있다
    s, e = graph[i*2], graph[i*2+1]

    # s정점에서 갈 수 있는 곳 중에 e 정점이 있다
    adj[s].append(e)
    # e정점에서 갈 수 있는 곳 중에 s 정점이 있다
    adj[e].append(s)
#
for i in range(V+1):
    print(adj[i])


# s: 탐색을 시작하는 정점 번호
# N: 정점의 개수(마지막 정점 번호
def DFS(s, N):
    # 깊이우선탐색 : 한 방향으로 가능한 깊게 탐색한 후에 더이상 갈 곳이 없으면 가장 마지막에
    # 방문한 정점으로 돌아온다. 한 번 탐색한 정점은 다시 참색하지 않는다 => 탐색여부 저장하는 배열
    visited = [0] * (N+1)
    # x번 탐색한 적 있음 => visited[x] = 1
    # y번 탐색한 적 없음 => visited[y] = 0

    # 가장 마지막에 방문한 정점으로 쉽게 돌아가기 위해 스택 사용
    stack = []

    # 현재 탐색중인 정점 번호
    v = s

    # 시작 정점을 방문했다고 체크 : 1로 바꾼다
    visited[s] = 1
    print(v, end=' ')

    while True:
        # 현재 정점 v에서 탐색
        # v에서 갈 수 있는 다른 정점을 찾는 것 부터 시작
        # nv : 다른 정점 번호, v에서 갈 수 있는 정점 중에 하나
        for nv in adj[v]:
            # 갈 수 있다. => v에서 nv로 갈 수 있느냐를 판단
            # v와 nv가 인접해있고, nv를 이전에 방문한적이 없다면 갈 수 없다!!!!!!
            if not visited[nv]:
                # v에서 nv로 가는 길이 있었고, nv를 방문한 적도 없었다
                # nv로 일단 가자
                # 가기 전에 현재 위치를 스택에 저장(왔던 길 기억)
                stack.append(v)
                # nv로 이동
                v = nv
                # nv 다음에 또 오면 안되니깐 방문했다고 표시
                visited[nv] = 1
                print(nv, end=' ')
                # nv로 이동했으니 다른 갈 수 있는 정점은 보지 않아도 된다
                break
        # for ~ else
        else:
            # 중간에 break를 한 적이 없다면 실행되는 코드
            # break 한 적 없다 => 갈 수 있는 다른 정점을 찾지 못했다. (현재 위치 v 기준)
            # 갈 곳이 없으니 돌아간다. 돌아갈 곳은 스택에 저장해놨다
            # 가장 최근에 방문했던 곳으로 돌아가야하는데, 스택은 후입선출 구조라서
            # 원소를 하나 꺼내면 그곳이 바로 가장 최근에 방문했던 정점이 된다.
            # 꺼내기 전에 비어있지 않은가 확인
            if stack:
                # 비어있지 않으면 돌아갈 곳이 있다.
                v = stack.pop()
            else:
                # 더이상 갈 수 있는 곳도 없고 돌아갈 곳도 없으먄 탐색종료
                break
DFS(1, V)
